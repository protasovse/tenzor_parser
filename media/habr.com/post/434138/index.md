Пишем собственную виртуальную машину
====================================

В этом руководстве я расскажу, как написать собственную виртуальную машину (VM), способную запускать программы на ассемблере, такие как [2048](https://github.com/rpendleton/lc3-2048) (моего друга) или [Roguelike](https://github.com/justinmeiners/lc3-rogue) (моя). Если вы умеете программировать, но хотите лучше понять, что происходит внутри компьютера и как работают языки программирования, то этот проект для вас. Написание собственной виртуальной машины может показаться немного страшным, но я обещаю, что тема удивительно простая и поучительная.  
   
 [Окончательный код](https://justinmeiners.github.io/lc3-vm/src/lc3.c) составляет около 250 строк на C. Достаточно знать лишь основы C или C++, такие как [двоичная арифметика](https://www.swarthmore.edu/NatSci/echeeve1/Ref/BinaryMath/BinaryMath.html). Для сборки и запуска подходит любая Unix-система (включая macOS). Несколько API Unix используются для настройки ввода и отображения консоли, но они не являются существенными для основного кода. (Реализация поддержки Windows приветствуется).  
   
 
> **Примечание:** эта VM — [грамотная программа](https://en.wikipedia.org/wiki/Literate_programming). То есть вы прямо сейчас уже читаете её исходный код! Каждый фрагмент кода будет показан и подробно объяснён, так что можете быть уверены: ничего не упущено. Окончательный код создан [сплетением](https://github.com/zyedidia/Literate) блоков кода. Репозиторий проекта [тут](https://github.com/justinmeiners/lc3-vm).  
 1. Оглавление
=============

  
  2. [Оглавление](#1)
 4. [Введение](#2)
 6. [Архитектура LC-3](#3)
 8. [Примеры на ассемблере](#4)
 10. [Выполнение программ](#5)
 12. [Реализация инструкций](#6)
 14. [Шпаргалка по инструкциям](#7)
 16. [Процедуры обработки прерываний](#8)
 18. [Шпаргалка по процедурам обработки прерываний](#9)
 20. [Загрузка программ](#10)
 22. [Отображаемые в памяти регистры](#11)
 24. [Особенности платформы](#12)
 26. [Запуск виртуальной машины](#13)
 28. [Альтернативный метод на C++](#14)
   
 2. Введение
===========

  
 ### Что такое виртуальная машина?

  
 Виртуальная машина — это программа, которая действует как компьютер. Она имитирует процессор с несколькими другими аппаратными компонентами, позволяя выполнять арифметику, считывать из памяти и записывать туда, а также взаимодействовать с устройствами ввода-вывода, словно настоящий физический компьютер. Самое главное, VM понимает машинный язык, который вы можете использовать для программирования.  
   
 Сколько аппаратного обеспечения имитирует конкретная VM — зависит от её предназначения. Некоторые VM воспроизводят поведение одного конкретного компьютера. У людей больше нет NES, но мы всё ещё можем играть в игры для NES, имитируя аппаратное обеспечение на программном уровне. Эти эмуляторы должны [точно воссоздать](http://wiki.nesdev.com/w/index.php/Tricky-to-emulate_games) каждую [деталь](http://wiki.nesdev.com/w/index.php/Emulator_tests) и каждый основной аппаратный компонент оригинального устройства.  
   
 Другие VM не соответствуют никакому конкретному компьютеру, а частично соответствуют сразу нескольким! В первую очередь это делается для облегчения разработки ПО. Представьте, что вы хотите создать программу, работающую на нескольких компьютерных архитектурах. Виртуальная машина даёт стандартную платформу, которая обеспечивает переносимость. Не нужно переписывать программу на разных диалектах ассемблера для каждой архитектуры. Достаточно сделать только небольшую VM на каждом языке. После этого любую программу можно написать лишь единожды на языке ассемблера виртуальной машины.  
   
 ![](https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif)  
 ![](https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif)  
 
> **Примечание:** компилятор решает подобные проблемы, компилируя стандартный *высокоуровневый язык* для разных процессорных архитектур. VM создаёт одну стандартную *архитектуру CPU*, которая симулируется на различных аппаратных устройствах. Одно из преимуществ компилятора в том, что отсутствуют накладные расходы во время выполнения, как у VM. Хотя компиляторы хорошо работают, написание нового компилятора для нескольких платформ очень трудно, поэтому VM всё ещё полезны. В реальности на разных уровнях и VM, и компиляторы используются совместно.  
 [Виртуальная машина Java (JVM)](https://en.wikipedia.org/wiki/Java_virtual_machine) — очень успешный пример. Сама JVM относительно среднего размера, она достаточно мала для понимания программистом. Это позволяет писать код для тысяч разнообразных устройств, включая телефоны. После реализации JVM на новом устройстве любая написанная программа Java, Kotlin или Clojure может работать на нём без изменений. Единственными затратами будут только накладные расходы на саму VM и [дальнейшее абстрагирование](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/) от машинного уровня. Обычно это довольно хороший компромисс.  
   
 VM не обязательно должна быть большой или вездесущной, чтобы обеспечить аналогичные преимущества. Старые [видеоигры](https://fabiensanglard.net/anotherWorld_code_review/) часто использовали небольшие VM для создания простых [скриптовых систем](https://sf2platinum.wordpress.com/page/1/).  
   
 VM также полезны для безопасной изоляции программ. Одно из применений — сборка мусора. [Не существует тривиального способа](https://www.lua.org/pil/24.2.html) реализовать автоматическую сборку мусора поверх C или C++, так как программа не может видеть собственный стек или переменные. Однако VM находится «вне» запущенной программы и может наблюдать все [ссылки на ячейки памяти](https://en.wikipedia.org/wiki/Tracing_garbage_collection) в стеке.  
   
 Ещё один пример такого поведения демонстрируют [смарт-контракты Ethereum](https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html). Смарт-контракты — это небольшие программы, которые выполняются каждым узлом валидации в блокчейне. То есть операторы разрешают выполнение на своих машинах любых программ, написанных совершенно незнакомыми людьми, без какой-либо возможности изучить их заранее. Чтобы предотвратить вредоносные действия, они выполняются на [VM](http://ethdocs.org/en/latest/introduction/what-is-ethereum.html#ethereum-virtual-machine), не имеющей доступа к файловой системе, сети, диску и т.д. Ethereum — также хороший пример переносимости. Благодаря VM можно писать смарт-контракты без учёта особенностей множества платформ.  
   
 3. Архитектура LC-3
===================

  
 ![](https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png)  
   
 Наша VM будет симулировать вымышленный компьютер под названием [LC-3](https://en.wikipedia.org/wiki/LC-3). Он популярен для обучения студентов ассемблеру. Здесь упрощённый набор команд [по сравнению с x86](http://ref.x86asm.net/coder64.html), но сохраняются все основные концепции, которые используются в современных CPU.  
   
 Во-первых, нужно сымитировать необходимые аппаратные компоненты. Попытайтесь понять, что представляет собой каждый компонент, но не волнуйтесь, если не уверены, как он вписывается в общую картину. Начнём с создания файла на С. Каждый фрагмент кода из этого раздела следует поместить в глобальную область видимости этого файла.  
   
 ### Память

  
 В компьютере LC-3 есть 65 536 ячеек памяти (216), каждая из которых содержит 16-разрядное значение. Это означает, что он может хранить всего 128 Кб — намного меньше, чем вы привыкли! В нашей программе эта память хранится в простом массиве:  
   
 /* 65536 locations */ uint16\_t memory[UINT16\_MAX];  
 ### Регистры

  
 Регистр — это слот для хранения одного значения в CPU. Регистры подобны «верстаку» CPU. Чтобы он мог работать с каким-то фрагментом данных, тот должен находиться в одном из регистров. Но поскольку регистров всего несколько, в любой момент времени можно загрузить только минимальный объём данных. Программы обходят эту проблему, загружая значения из памяти в регистры, вычисляя значения в другие регистры, а затем сохраняя окончательные результаты обратно в память.  
   
 В компьютере LC-3 всего 10 регистров, каждый на 16 бит. Большинство из них —общего назначения, но некоторым назначены роли.  
   
  * 8 регистров общего назначения (R0-R7)
 * 1 регистр счётчика команд (PC)
 * 1 регистр флагов условий (COND)
   
 Регистры общего назначения могут использоваться для выполнения любых программных вычислений. Счётчик команд представляет собой целое число без знака, которое является адресом в памяти следующей инструкции для выполнения. Флаги условий сообщают нам информацию о предыдущем вычислении.  
   
 enum { R\_R0 = 0, R\_R1, R\_R2, R\_R3, R\_R4, R\_R5, R\_R6, R\_R7, R\_PC, /* program counter */ R\_COND, R\_COUNT };  
 Как и память, будем хранить регистры в массиве:  
   
 uint16\_t reg[R\_COUNT];  
 ### Набор инструкций

  
 Инструкция — это команда, которая говорит процессору выполнить какую-то фундаментальную задачу, например, сложить два числа. У инструкции есть **опкод** (код операции), указывающий тип выполняемой задачи, а также набор **параметров**, которые предоставляют входные данные для выполняемой задачи.  
   
 Каждый **опкод** представляет собой одну задачу, которую процессор «знает», как выполнить. В LC-3 всего 16 опкодов. Компьютер может вычислить только последовательность этих простых инструкций. Длина каждой инструкции 16 бит, а левые 4 бита хранят код операции. Остальные используются для хранения параметров.  
   
 Позже подробно обсудим, что делает каждая инструкция. На данный момент определите следующие опкоды. Удостоверьтесь, что сохраняют такой порядок, чтобы получать правильное значение enum:  
   
 enum { OP\_BR = 0, /* branch */ OP\_ADD, /* add */ OP\_LD, /* load */ OP\_ST, /* store */ OP\_JSR, /* jump register */ OP\_AND, /* bitwise and */ OP\_LDR, /* load register */ OP\_STR, /* store register */ OP\_RTI, /* unused */ OP\_NOT, /* bitwise not */ OP\_LDI, /* load indirect */ OP\_STI, /* store indirect */ OP\_JMP, /* jump */ OP\_RES, /* reserved (unused) */ OP\_LEA, /* load effective address */ OP\_TRAP /* execute trap */ };  
 
> **Примечание:** в архитектуре Intel x86 сотни инструкций, в то время как в других архитектурах, таких как ARM и LC-3, очень мало. Небольшие наборы инструкций называются [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer), а более крупные — [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer). Большие наборы инструкций, как правило, не предоставляют принципиально новых возможностей, но [часто упрощают написание ассемблерного кода](https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/). Одна инструкция CISC может заменить несколько инструкций RISC. Однако процессоры CISC более сложны и дороги в проектировании и производстве. Это и другие компромиссы [не позволяют назвать «оптимальный» дизайн](https://cs.stackexchange.com/questions/269/why-would-anyone-want-cisc).  
 ### Флаги условий

  
 Регистр R\_COND хранит флаги условий, которые предоставляют информацию о последнем выполненном вычислении. Это позволяет программам проверять логические условия, такие как if (x > 0) { ... }.  
   
 У каждого процессора множество флагов состояния для сигнализации о различных ситуациях. LC-3 использует только три флага условий, которые показывают знак предыдущего вычисления.  
   
 enum { FL\_POS = 1 << 0, /* P */ FL\_ZRO = 1 << 1, /* Z */ FL\_NEG = 1 << 2, /* N */ };  
 
> **Примечание:** (Символ << называется [оператором левого сдвига](https://msdn.microsoft.com/en-us/library/336xbhcz.aspx). (n << k) сдвигает биты n влево на k мест. Таким образом, 1 << 2 равняется 4. Почитайте [здесь](https://msdn.microsoft.com/en-us/library/336xbhcz.aspx), если не знакомы с концепцией. Это будет очень важно).  
 Мы закончили настройку аппаратных компонентов нашей виртуальной машины! После добавления стандартных включений (см. по ссылке выше) ваш файл должен выглядеть примерно так:  
   
 {Includes, 12} {Registers, 3} {Opcodes, 3} {Condition Flags, 3}Здесь указаны ссылки на пронумерованные разделы статьи, откуда берутся соответствующие фрагменты кода. Полный листинг см. в [рабочей программе](https://justinmeiners.github.io/lc3-vm/index.html) — прим. пер.   
   
 4. Примеры на ассемблере
========================

  
 Теперь рассмотрим программу на ассемблере LC-3, чтобы получить представление, что фактически выполняет виртуальная машина. Вам не нужно знать, как программировать на ассемблере, или всё тут понимать. Просто постарайтесь получить общее представление, что происходит. Вот простой «Hello World»:  
   
 .ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO\_STR ; load the address of the HELLO\_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO\_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file  
 Как и в C, программа выполняет по одному оператору сверху вниз. Но в отличие от C, здесь нет вложенных областей {} или управляющих структур, таких как if или while; только простой список операторов. Поэтому его гораздо легче выполнить.  
   
 Обратите внимание, что имена некоторых операторов соответствуют опкодам, которые мы определили ранее. Мы знаем, что в инструкциях по 16 бит, но каждая строка выглядит как будто с разным количеством символов. Как возможно такое несоответствие?  
   
 Это происходит потому что код, который мы читаем, написан на **ассемблере** — в удобочитаемой и доступной для записи форме обычным текстом. Инструмент, называемый **ассемблером**, преобразует каждую строку текста в 16-разрядную двоичную инструкцию, понятную виртуальной машине. Эта двоичная форма, которая по сути представляет собой массив 16-разрядных инструкций, называется **машинным кодом** и фактически выполняется виртуальной машиной.  
   
 ![](https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif)  
 
> **Примечание:** хотя компилятор и ассемблер играют схожую роль в разработке, они не одинаковы. Ассемблер просто кодирует то, что программист написал в тексте, заменяя символы их двоичным представлением и упаковывая их в инструкции.  
 Команды .ORIG и .STRINGZ выглядят как инструкции, но нет. Это директивы ассемблера, которые генерируют часть кода или данных. Например, .STRINGZ вставляет строку символов в указанном месте двоичной программы.  
   
 Циклы и условия выполняются с помощью goto-подобной инструкции. Вот еще один пример, который считает до 10.  
   
 AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!  
 
> **Примечание:** для этого руководства необязательно учиться ассемблеру. Но если вам интересно, можете написать и собрать собственные программы LC-3 с помощью [LC-3 Tools](http://highered.mheducation.com/sites/0072467509/student_view0/lc-3_simulator.html).  
 5. Выполнение программ
======================

  
 Ещё раз, предыдущие примеры просто дают представление, что делает VM. Для написания VM вам не нужно полное понимание ассемблера. Пока вы следуете соответствующей процедуре чтения и исполнения инструкций, *любая* программа LC-3 будет корректно работать, независимо от её сложности. В теории, VM может запустить даже браузер или операционную систему, как Linux!  
   
 Если глубоко задуматься, то это философски замечательная идея. Сами программы могут производить сколь угодно сложные действия, которые мы никогда не ожидали и, возможно, не сможем понять. Но в то же время вся их функциональность ограничивается простым кодом, который мы напишем! Мы одновременно знаем всё и ничего о том, как работает каждая программа. Тьюринг упоминал эту чудесную идею:  
   
 
> «Мнение о том, что машины не могут чем-либо удивить человека, основывается, как я полагаю, на одном заблуждении, которому в особенности подвержены математики и философы. Я имею в виду предположение о том, что коль скоро какой-то факт стал достоянием разума, тотчас же достоянием разума становятся все следствия из этого факта». — [Алан М. Тьюринг](https://academic.oup.com/mind/article-pdf/LIX/236/433/9866119/433.pdf)  
 ### Процедура

  
 Вот точное описание процедуры, которую нужно написать:  
   
  2. Загрузить одну инструкцию из памяти по адресу регистра PC.
 4. Увеличить регистр PC.
 6. Посмотреть опкод, чтобы определить, какой тип инструкции выполнять.
 8. Выполнить инструкцию, используя её параметры.
 10. Вернуться к шагу 1.
   
 Вы можете задать вопрос: «Но если цикл продолжает увеличивать счётчик в отсутствие if или while, инструкции разве не закончатся?» Ответ отрицательный. Как мы уже упоминали, некоторые goto-подобные инструкции изменяют поток выполнения, прыгая вокруг PC.  
   
 Начнём изучение этого процесса на примере основного цикла:  
   
 int main(int argc, const char* argv[]) { {Load Arguments, 12} {Setup, 12} /* set the PC to starting position */ /* 0x3000 is the default */ enum { PC\_START = 0x3000 }; reg[R\_PC] = PC\_START; int running = 1; while (running) { /* FETCH */ uint16\_t instr = mem\_read(reg[R\_PC]++); uint16\_t op = instr >> 12; switch (op) { case OP\_ADD: {ADD, 6} break; case OP\_AND: {AND, 7} break; case OP\_NOT: {NOT, 7} break; case OP\_BR: {BR, 7} break; case OP\_JMP: {JMP, 7} break; case OP\_JSR: {JSR, 7} break; case OP\_LD: {LD, 7} break; case OP\_LDI: {LDI, 6} break; case OP\_LDR: {LDR, 7} break; case OP\_LEA: {LEA, 7} break; case OP\_ST: {ST, 7} break; case OP\_STI: {STI, 7} break; case OP\_STR: {STR, 7} break; case OP\_TRAP: {TRAP, 8} break; case OP\_RES: case OP\_RTI: default: {BAD OPCODE, 7} break; } } {Shutdown, 12} }  
 6. Реализация инструкций
========================

  
 Теперь ваша задача — сделать правильную реализацию для каждого опкода. Подробная спецификация каждой инструкции содержится в [документации проекта](https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf). Из спецификации нужно узнать, как работает каждая инструкция, и написать реализацию. Это проще, чем кажется. Здесь я продемонстрирую, как реализовать две из них. Код для остальных можно найти в следующем разделе.  
   
 ### ADD

  
 Инструкция ADD берёт два числа, складывает их и сохраняет результат в регистре. Спецификация в документации на стр. 526. Каждая инструкция ADD выглядит следующим образом:  
   
 ![](https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif)  
   
 На схеме две строки, потому что для этой инструкции есть два различных «режима». Прежде чем я объясню режимы, давайте попробуем найти сходство между ними. Обе они начинаются с четырёх одинаковых битов 0001. Это значение опкода для OP\_ADD. Следующие три бита помечены DR для выходного регистра. Выходной регистр — это место хранения суммы. Следующие три бита: SR1. Это регистр, содержащий первое добавляемое число.  
   
 Таким образом, мы знаем, где сохранить результат, и знаем первое число для сложения. Осталось только узнать второе число для сложения. Здесь две строки начинают различаться. Обратите внимание, что вверху 5-й бит равен 0, а внизу — 1. Этот бит соответствует или *непосредственному режиму*, или *регистровому режиму*. В регистровом режиме второе число хранится в регистре, как и первое. Оно отмечено как SR2 и содержится в битах со второго по нулевой. Биты 3 и 4 не используются. На ассемблере это будет написано так:  
   
 ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.  
 В непосредственном режиме вместо добавления содержимого регистра непосредственное значение внедряется в саму инструкцию. Это удобно, потому что программе не нужны дополнительные инструкции для загрузки этого числа в регистр из памяти. Вместо этого оно уже внутри инструкции, когда нам нужно. Компромисс в том, что там могут храниться только небольшие числа. Если быть точным, максимум 25=32. Это наиболее полезно для увеличения счётчиков или значений. На ассемблере можно написать так:  
   
 ADD R0 R0 1 ; add 1 to R0 and store back in R0  
 Вот выдержка из спецификации:  
   
 
> Если бит [5] равен 0, то второй исходный операнд получают из SR2. Если бит [5] равен 1, то второй исходный операнд получают путём расширения значения imm5 до 16 бит. В обоих случаях второй исходный операнд добавляется к содержимому SR1, а результат сохраняется в DR. (стр. 526)  
 Это похоже на то, что мы обсуждали. Но что такое «расширение значения»? Хотя в непосредственном режиме у значения только 5 бит, его нужно сложить с 16-разрядным числом. Эти 5 бит следует расширить до 16, чтобы соответствовать другому числу. Для положительных чисел мы можем заполнить недостающие биты нулями и получить такое же значение. Однако для отрицательных чисел это не работает. Например, −1 в пяти битах равно 1 1111. Если просто заполнить нулями, получим 0000 0000 0001 1111, что равно 32! Расширение значения предотвращает эту проблему, заполняя биты нулями для положительных чисел и единицами для отрицательных чисел.  
   
 uint16\_t sign\_extend(uint16\_t x, int bit\_count) { if ((x >> (bit\_count - 1)) & 1) { x |= (0xFFFF << bit\_count); } return x; }  
 
> **Примечание:** если вас интересуют двоичные отрицательные числа, можете прочитать о [дополнительном коде](https://en.wikipedia.org/wiki/Two%27s_complement). Но это не существенно. Достаточно просто скопировать код выше и использовать его, когда спецификация говорит расширить значение.  
 В спецификации есть последнее предложение:  
   
 
> Коды условий задаются в зависимости от того, является ли результат отрицательным, нулевым или положительным. (стр. 526)  
 Ранее мы определили условие flags enum, а теперь пришло время использовать этих флаги. Каждый раз, когда значение записывается в регистр, нам нужно обновить флаги, чтобы указать его знак. Напишем функцию для повторного использования:  
   
 void update\_flags(uint16\_t r) { if (reg[r] == 0) { reg[R\_COND] = FL\_ZRO; } else if (reg[r] >> 15) /* a 1 in the left-most bit indicates negative */ { reg[R\_COND] = FL\_NEG; } else { reg[R\_COND] = FL\_POS; } }  
 Теперь мы готовы написать код для ADD:  
   
 { /* destination register (DR) */ uint16\_t r0 = (instr >> 9) & 0x7; /* first operand (SR1) */ uint16\_t r1 = (instr >> 6) & 0x7; /* whether we are in immediate mode */ uint16\_t imm\_flag = (instr >> 5) & 0x1; if (imm\_flag) { uint16\_t imm5 = sign\_extend(instr & 0x1F, 5); reg[r0] = reg[r1] + imm5; } else { uint16\_t r2 = instr & 0x7; reg[r0] = reg[r1] + reg[r2]; } update\_flags(r0); }  
 В этом разделе много информации, поэтому подведём итоги.  
   
  * ADD берёт два значения и сохраняет их в регистре.
 * В регистровом режиме второе добавляемое значение находится в регистре.
 * В непосредственном режиме второе значение внедряется в правые 5 бит инструкции.
 * Значения короче 16 бит следует расширить.
 * Каждый раз, когда инструкция изменяет регистр, следует обновить флаги условий.
   
 Вы можете быть ошеломлены написанием ещё 15 инструкций. Однако полученную здесь информацию можно использовать повторно. В большинстве инструкций используется комбинация расширения значения, различных режимов и обновления флагов.  
   
 ### LDI

  
 LDI означает «косвенную» или «непрямую» загрузку (load indirect). Эта инструкция используется для загрузки в регистр значения из места в памяти. Спецификация на стр. 532.  
   
 Вот как выглядит двоичная компоновка:  
   
 ![](https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif)  
   
 В отличие от ADD, здесь нет режимов и меньше параметров. На этот раз код операции 1010, что соответствует значению enum OP\_LDI. Опять же мы видим трёхбитный DR (выходной регистр) для хранения загруженного значения. Остальные биты помечены как PCoffset9. Это непосредственное значение, встроенное в инструкцию (аналогично imm5). Поскольку инструкция загружается из памяти, мы можем догадаться, что это число является своего рода адресом, который говорит, откуда загружать значение. Спецификация объясняет подробнее:  
   
 
> Адрес вычисляется с помощью расширения битов значения [8:0] до 16 бит и добавления этого значения к увеличенному PC. Что хранится в памяти по этому адресу — это адрес данных, которые будут загружены в DR. (стр. 532)  
 Как и раньше, нужно расширить это 9-битное значение, но на этот раз добавить его к текущему PC. (Если вы посмотрите на цикл выполнения, PC увеличился сразу после загрузки этой инструкции). Результирующая сумма — это адрес местоположения в памяти, и этот адрес *содержит ещё одно* значение, которое является адресом загружаемого значения.  
   
 Это может показаться окольным путём для чтения из памяти, но так нужно. Инструкция LD ограничена адресным смещением 9 бит, тогда как память требует для адреса 16 бит. LDI полезна для загрузки значений, которые хранятся где-то за пределами текущего компьютера, но для их использования адрес конечного местоположения должен храниться рядом. Вы можете думать о ней как о локальной переменной в C, которая является указателем на некоторые данные:  
   
 // the value of far\_data is an address // of course far\_data itself (the location in memory containing the address) has an address char* far\_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far\_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0  
 Как и раньше, после записи значения в DR следует обновить флаги:  
   
 
> Коды условий задаются в зависимости от того, является ли результат отрицательным, нулевым или положительным. (стр. 532)  
 Вот код для данного случая: (mem\_read обсудим в следующем разделе):  
   
 { /* destination register (DR) */ uint16\_t r0 = (instr >> 9) & 0x7; /* PCoffset 9*/ uint16\_t pc\_offset = sign\_extend(instr & 0x1ff, 9); /* add pc\_offset to the current PC, look at that memory location to get the final address */ reg[r0] = mem\_read(mem\_read(reg[R\_PC] + pc\_offset)); update\_flags(r0); }  
 Как я уже сказал, для этой инструкции мы использовали значительную часть кода и знаний, полученных ранее при написании ADD. То же самое с остальными инструкциями.  
   
 Теперь необходимо реализовать остальные инструкции. Следуйте [спецификации](https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf) и используйте уже написанный код. Код для всех инструкций приведён в конце статьи. Два из перечисленных ранее опкодов нам не понадобятся: это OP\_RTI и OP\_RES. Можно их проигнорировать или выдать ошибку, если они вызываются. Когда закончите, основную часть вашей VM можно считать завершённой!  
   
 7. Шпаргалка по инструкциям
===========================

  
 В этом разделе — полные реализации оставшихся инструкций, если вы застряли.  
   
 ### RTI & RES

  
 (не используются)  
   
 abort();  
 ### [Битовое «И»](https://en.wikipedia.org/wiki/Bitwise_operation#AND)

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t r1 = (instr >> 6) & 0x7; uint16\_t imm\_flag = (instr >> 5) & 0x1; if (imm\_flag) { uint16\_t imm5 = sign\_extend(instr & 0x1F, 5); reg[r0] = reg[r1] & imm5; } else { uint16\_t r2 = instr & 0x7; reg[r0] = reg[r1] & reg[r2]; } update\_flags(r0); }  
 ### [Битовое «НЕ»](https://en.wikipedia.org/wiki/Bitwise_operation#NOT)

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t r1 = (instr >> 6) & 0x7; reg[r0] = ~reg[r1]; update\_flags(r0); }  
 ### Branch

  
 { uint16\_t pc\_offset = sign\_extend((instr) & 0x1ff, 9); uint16\_t cond\_flag = (instr >> 9) & 0x7; if (cond\_flag & reg[R\_COND]) { reg[R\_PC] += pc\_offset; } }  
 ### Jump

  
 RET указана как отдельная инструкция в спецификации, так как это другая команда в ассемблере. На самом деле это особый случай JMP. RET происходит всякий раз, когда R1 равно 7.  
   
 { /* Also handles RET */ uint16\_t r1 = (instr >> 6) & 0x7; reg[R\_PC] = reg[r1]; }  
 ### Jump Register

  
 { uint16\_t r1 = (instr >> 6) & 0x7; uint16\_t long\_pc\_offset = sign\_extend(instr & 0x7ff, 11); uint16\_t long\_flag = (instr >> 11) & 1; reg[R\_R7] = reg[R\_PC]; if (long\_flag) { reg[R\_PC] += long\_pc\_offset; /* JSR */ } else { reg[R\_PC] = reg[r1]; /* JSRR */ } break; }  
 ### Load

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t pc\_offset = sign\_extend(instr & 0x1ff, 9); reg[r0] = mem\_read(reg[R\_PC] + pc\_offset); update\_flags(r0); }  
 ### Load Register

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t r1 = (instr >> 6) & 0x7; uint16\_t offset = sign\_extend(instr & 0x3F, 6); reg[r0] = mem\_read(reg[r1] + offset); update\_flags(r0); }  
 ### Эффективный адрес Load

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t pc\_offset = sign\_extend(instr & 0x1ff, 9); reg[r0] = reg[R\_PC] + pc\_offset; update\_flags(r0); }  
 ### Store

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t pc\_offset = sign\_extend(instr & 0x1ff, 9); mem\_write(reg[R\_PC] + pc\_offset, reg[r0]); }  
 ### Store Indirect

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t pc\_offset = sign\_extend(instr & 0x1ff, 9); mem\_write(mem\_read(reg[R\_PC] + pc\_offset), reg[r0]); }  
 ### Store Register

  
 { uint16\_t r0 = (instr >> 9) & 0x7; uint16\_t r1 = (instr >> 6) & 0x7; uint16\_t offset = sign\_extend(instr & 0x3F, 6); mem\_write(reg[r1] + offset, reg[r0]); }  
 8. Процедуры обработки прерываний
=================================

  
 LC-3 обеспечивает несколько предопределённых подпрограмм для выполнения общих задач и взаимодействия с устройствами ввода-вывода. Например, есть процедуры для получения ввода с клавиатуры и вывода строк на консоль. Они называются *программами обработки системных прерываний* (trap routines), которые вы можете представлять как операционную систему или API для LC-3. Каждой подпрограмме присваивается код прерывания (trap-код), который её идентифицирует (аналогично опкоду). Для её выполнения вызывается инструкция TRAP с кодом нужной подпрограммы.  
   
 ![](https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif)  
   
 Установим enum для каждого кода прерывания:  
   
 enum { TRAP\_GETC = 0x20, /* get character from keyboard */ TRAP\_OUT = 0x21, /* output a character */ TRAP\_PUTS = 0x22, /* output a word string */ TRAP\_IN = 0x23, /* input a string */ TRAP\_PUTSP = 0x24, /* output a byte string */ TRAP\_HALT = 0x25 /* halt the program */ };  
 Вам может быть интересно, почему коды прерываний не включены в инструкции. Это потому что они фактически не добавляют LC-3 никакой новой функциональности, а только обеспечивают удобный способ выполнения задачи (подобно системным функциям в C). В официальном симуляторе LC-3 коды прерываний [написаны на ассемблере](https://justinmeiners.github.io/lc3-vm/supplies/os.asm). При вызове кода прерывания компьютер перемещается по адресу этого кода. CPU выполняет инструкции процедуры, а по завершении PC сбрасывается в местоположение, откуда было вызвано прерывание.  
   
 
> **Примечание:** вот почему программы начинаются с адреса 0x3000 вместо 0x0. Нижние адреса остаются пустыми, чтобы оставить место для кода подпрограммы обработки прерываний.  
 Нет никакой спецификации, *как* реализовать подпрограммы обработки прерываний: только то, что они должны делать. В нашей VM мы поступим немного иначе, написав их на C. При вызове кода прерывания будет вызвана функция C. После её работы продолжится выполнение инструкции.  
   
 Хотя процедуры можно написать на ассемблере и в физическом компьютере LC-3 так и будет, это не лучший вариант для VM. Вместо написания собственных примитивных процедур ввода-вывода можно воспользоваться теми, которые доступны на нашей ОС. Это улучшит работу виртуальной машины на наших компьютерах, упростит код и обеспечит более высокий уровень абстракции для переносимости.  
   
 
> **Примечание:** одним из конкретных примеров является ввод с клавиатуры. В ассемблерной версии используется цикл для непрерывной проверки ввода клавиатуры. Но ведь так впустую тратится много процессорного времени! При использовании надлежащей функции ОС программа может спокойно спать до входного сигнала.  
 В оператор множественного выбора для опкода TRAP добавим ещё один switch:  
   
 switch (instr & 0xFF) { case TRAP\_GETC: {TRAP GETC, 9} break; case TRAP\_OUT: {TRAP OUT, 9} break; case TRAP\_PUTS: {TRAP PUTS, 8} break; case TRAP\_IN: {TRAP IN, 9} break; case TRAP\_PUTSP: {TRAP PUTSP, 9} break; case TRAP\_HALT: {TRAP HALT, 9} break; }  
 Как и в случае с инструкциями, я покажу, как реализовать одну процедуру, а остальное сделаете сами.  
   
 ### PUTS

  
 Код прерывания PUTS используется для выдачи строки с завершающим нулём (аналогично printf в C). Спецификация на стр. 543.  
   
 Чтобы отобразить строку, мы должны дать подпрограмме обработки прерываний строку для отображения. Это делается путём сохранения адреса первого символа в R0 перед началом обработки.  
   
 Из спецификации:  
   
 
> Выведите строку символов ASCII на дисплей консоли. Символы содержатся в последовательных ячейках памяти, по одному символу на ячейку, начиная с адреса, указанного в R0. Вывод завершается, когда в памяти встречается значение x0000. (стр. 543)  
 Обратите внимание, что в отличие от строк C, здесь символы хранятся *не в одном байте, а по одному расположению в памяти*. Расположение в памяти LC-3 составляет 16 бит, поэтому у каждого символа в строке размер 16 бит. Чтобы отобразить это в функции C, нужно преобразовать каждое значение в символ и вывести их по отдельности.  
   
 { /* one char per word */ uint16\_t* c = memory + reg[R\_R0]; while (*c) { putc((char)*c, stdout); ++c; } fflush(stdout); }  
 Для данной процедуры больше ничего не требуется. Подпрограммы обработки прерываний довольно просты, если вы знаете C. Теперь вернитесь к спецификации и реализуйте остальные. Как и в случае с инструкциями, полный код можно найти в конце этого руководства.  
   
 9. Шпаргалка по процедурам обработки прерываний
===============================================

  
 Этот раздел содержит полные реализации остальных подпрограмм обработки прерываний.  
   
 ### Ввод символа

  
 /* read a single ASCII char */ reg[R\_R0] = (uint16\_t)getchar();  
 ### Вывод символа

  
 putc((char)reg[R\_R0], stdout); fflush(stdout);  
 ### Запрос ввода символа

  
 printf("Enter a character: "); reg[R\_R0] = (uint16\_t)getchar();  
 ### Вывод строки

  
 { /* one char per byte (two bytes per word) here we need to swap back to big endian format */ uint16\_t* c = memory + reg[R\_R0]; while (*c) { char char1 = (*c) & 0xFF; putc(char1, stdout); char char2 = (*c) >> 8; if (char2) putc(char2, stdout); ++c; } fflush(stdout); }  
 ### Прекращение выполнения программы

  
 puts("HALT"); fflush(stdout); running = 0;  
 10. Загрузка программ
=====================

  
 Мы много говорили о загрузке и выполнении инструкций из памяти, но как вообще инструкции попадают в память? При преобразовании ассемблерной программы в машинный код результатом является файл, содержащий массив инструкций и данных. Его можно загрузить, просто скопировав содержимое прямо в адрес в памяти.  
   
 Первые 16 бит файла программы указывают адрес в памяти, где следует начать выполнение программы. Этот адрес называется **origin**. Он должен быть прочитан первым, после чего в память из файла считываются остальные данные.  
   
 Вот код для загрузки программы в память LC-3:  
   
 void read\_image\_file(FILE* file) { /* the origin tells us where in memory to place the image */ uint16\_t origin; fread(&origin, sizeof(origin), 1, file); origin = swap16(origin); /* we know the maximum file size so we only need one fread */ uint16\_t max\_read = UINT16\_MAX - origin; uint16\_t* p = memory + origin; size\_t read = fread(p, sizeof(uint16\_t), max\_read, file); /* swap to little endian */ while (read-- > 0) { *p = swap16(*p); ++p; } }  
 Обратите внимание, что для каждого загруженного значения вызывается swap16. Программы LC-3 записаны в прямом порядке байтов, но большинство современных компьютеров используют обратный порядок. В результате нам нужно перевернуть каждый загруженный uint16. (Если вы случайно используете [странный компьютер](https://en.wikipedia.org/wiki/Power_Mac_G4_Cube) вроде [PPC](https://en.wikipedia.org/wiki/PowerPC#Endian_modes), то ничего менять не надо).  
   
 uint16\_t swap16(uint16\_t x) { return (x << 8) | (x >> 8); }  
 
> **Примечание:** [Порядок байтов](https://en.wikipedia.org/wiki/Endianness) относится к тому, как интерпретируются байты целого числа. В обратном порядке первый байт является наименьшей значащей цифрой, а в прямом порядке — наоборот. Насколько мне известно, решение *в основном* произвольное. Разные компании принимали разные решения, так что теперь у нас различные реализации. Для этого проекта больше ничего не нужно знать о порядке байтов.  
 Добавим также удобную функцию для read\_image\_file, которая принимает путь для строки:  
   
 int read\_image(const char* image\_path) { FILE* file = fopen(image\_path, "rb"); if (!file) { return 0; }; read\_image\_file(file); fclose(file); return 1; }  
 11. Отображаемые в памяти регистры
==================================

  
 Некоторые специальные регистры недоступны из обычной таблицы регистров. Вместо этого для них в памяти зарезервирован специальный адрес. Чтобы читать и писать в эти регистры, вы просто читаете и записываете в их память. Они называются **отображаемыми в памяти регистрами**. Обычно они используются для взаимодействия со специальными аппаратными устройствами.  
   
 Для нашей LC-3 нужно реализовать два отображаемых в памяти регистра. Это регистр состояния клавиатуры (KBSR) и регистр данных клавиатуры (KBDR). Первый указывает, была ли нажата клавиша, а второй определяет, какая именно клавиша нажата.  
   
 Хотя ввод с клавиатуры можно запросить с помощью GETC, это блокирует выполнение до получения ввода. KBSR и KBDR позволяют [опрашивать состояние](https://en.wikipedia.org/wiki/Polling_(computer_science)) устройства, продолжая выполнение программы, так что она остаётся отзывчивой во время ожидания ввода.  
   
 enum { MR\_KBSR = 0xFE00, /* keyboard status */ MR\_KBDR = 0xFE02 /* keyboard data */ };  
 Отображаемые в памяти регистры немного усложняют доступ к памяти. Мы не можем читать и записывать в массив памяти напрямую, а вместо этого должны вызывать специальные функции — сеттер и геттер. После чтения памяти из регистра KBSR геттер проверит клавиатуру и обновляет оба местоположения в памяти.  
   
 void mem\_write(uint16\_t address, uint16\_t val) { memory[address] = val; } uint16\_t mem\_read(uint16\_t address) { if (address == MR\_KBSR) { if (check\_key()) { memory[MR\_KBSR] = (1 << 15); memory[MR\_KBDR] = getchar(); } else { memory[MR\_KBSR] = 0; } } return memory[address]; }  
 Это последний компонент виртуальной машины! Если вы реализовали остальные процедуры обработки прерываний и инструкции, то почти готовы попробовать её!  
   
 Всё написанное следует добавить в файл C в следующем порядке:  
   
 {Memory Mapped Registers, 11} {TRAP Codes, 8} {Memory Storage, 3} {Register Storage, 3} {Functions, 12} {Main Loop, 5}  
 12. Особенности платформы
=========================

  
 Этот раздел содержит некоторые утомительные детали, необходимые для доступа к клавиатуре и корректной работы. Здесь ничего интересного или познавательного о работе виртуальных машин. Не стесняйтесь копипаста!  
   
 Если пытаетесь запустить VM в операционной системе, отличной от Unix, например Windows, эти функции нужно заменить на соответствующие функции Windows.  
   
 uint16\_t check\_key() { fd\_set readfds; FD\_ZERO(&readfds); FD\_SET(STDIN\_FILENO, &readfds); struct timeval timeout; timeout.tv\_sec = 0; timeout.tv\_usec = 0; return select(1, &readfds, NULL, NULL, &timeout) != 0; }  
 Код для извлечения пути из аргументов программы и вывода примера использования, если они отсутствуют.  
   
 if (argc < 2) { /* show usage string */ printf("lc3 [image-file1] ...\n"); exit(2); } for (int j = 1; j < argc; ++j) { if (!read\_image(argv[j])) { printf("failed to load image: %s\n", argv[j]); exit(1); } }  
 Специфичный для Unix код настройки ввода с терминала.  
   
 struct termios original\_tio; void disable\_input\_buffering() { tcgetattr(STDIN\_FILENO, &original\_tio); struct termios new\_tio = original\_tio; new\_tio.c\_lflag &= ~ICANON & ~ECHO; tcsetattr(STDIN\_FILENO, TCSANOW, &new\_tio); } void restore\_input\_buffering() { tcsetattr(STDIN\_FILENO, TCSANOW, &original\_tio); }  
 Когда программа прерывается, мы хотим вернуть нормальные настройки консоли.  
   
 void handle\_interrupt(int signal) { restore\_input\_buffering(); printf("\n"); exit(-2); }  
 signal(SIGINT, handle\_interrupt); disable\_input\_buffering();  
 restore\_input\_buffering();  
 {Sign Extend, 6} {Swap, 10} {Update Flags, 6} {Read Image File, 10} {Read Image, 10} {Check Key, 12} {Memory Access, 11} {Input Buffering, 12} {Handle Interrupt, 12}  
 #include <stdio.h> #include <stdlib.h> #include <stdint.h> #include <string.h> #include <signal.h> #include <unistd.h> #include <fcntl.h> #include <sys/time.h> #include <sys/types.h> #include <sys/termios.h> #include <sys/mman.h>  
 Запуск виртуальной машины
=========================

  
 Теперь вы можете собрать и запустить виртуальную машину LC-3!  
   
  2. Скомпилируйте [программу](https://justinmeiners.github.io/lc3-vm/src/lc3.c) любимым компилятором.
 4. Загрузите собранную версию [2048](https://justinmeiners.github.io/lc3-vm/supplies/2048.obj) или [Rogue](https://justinmeiners.github.io/lc3-vm/supplies/rogue.obj).
 6. Запустите программу с obj-файлом в качестве аргумента:  
 lc3-vm path/to/2048.obj
 8. Играйте в 2048!
   
 Control the game using WASD keys. Are you on an ANSI terminal (y/n)? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+  
 ### Отладка

  
 Если программа работает неправильно, скорее всего, вы неправильно закодировали какую-то инструкцию. Это может быть сложно отладить. Рекомендую одновременно читать ассемблерный код программы — и с помощью отладчика пошагово выполнять инструкции виртуальной машины по одной. При чтении кода убедитесь, что VM переходит к положенной инструкции. Если возникнет несоответствие, то вы узнаете, какая инструкция вызвала проблему. Перечитайте спецификацию и перепроверьте код.  
   
 14. Альтернативный метод на C++
===============================

  
 Здесь показан продвинутый способ выполнения инструкций, который значительно уменьшает размер кода. Это совершенно необязательный раздел.  
   
 Поскольку C++ поддерживает мощные дженерики в процессе компиляции, мы можем создавать части инструкций с помощью компилятора. Этот метод уменьшает дублирование кода и на самом деле ближе к аппаратному уровню работы компьютера.  
   
 Идея в том, чтобы повторно использовать шаги, общие для каждой инструкции. Например, некоторые инструкции используют косвенную адресацию или расширение значения и добавление его к текущему значению PC. Согласитесь, неплохо было бы написать этот код один раз для всех инструкций?  
   
 Рассматривая инструкцию как последовательность шагов, мы видим, что каждая инструкция — всего лишь перестановка нескольких меньших шагов. Будем использовать битовые флаги, чтобы отметить, какие шаги выполнять для каждой инструкции. Значение 1 в бите номера инструкции указывает, что для этой инструкции компилятор должен включить данный раздел кода.  
   
 template <unsigned op> void ins(uint16\_t instr) { uint16\_t r0, r1, r2, imm5, imm\_flag; uint16\_t pc\_plus\_off, base\_plus\_off; uint16\_t opbit = (1 << op); if (0x4EEE & opbit) { r0 = (instr >> 9) & 0x7; } if (0x12E3 & opbit) { r1 = (instr >> 6) & 0x7; } if (0x0022 & opbit) { r2 = instr & 0x7; imm\_flag = (instr >> 5) & 0x1; imm5 = sign\_extend((instr) & 0x1F, 5); } if (0x00C0 & opbit) { // Base + offset base\_plus\_off = reg[r1] + sign\_extend(instr & 0x3f, 6); } if (0x4C0D & opbit) { // Indirect address pc\_plus\_off = reg[R\_PC] + sign\_extend(instr & 0x1ff, 9); } if (0x0001 & opbit) { // BR uint16\_t cond = (instr >> 9) & 0x7; if (cond & reg[R\_COND]) { reg[R\_PC] = pc\_plus\_off; } } if (0x0002 & opbit) // ADD { if (imm\_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 & opbit) // AND { if (imm\_flag) { reg[r0] = reg[r1] & imm5; } else { reg[r0] = reg[r1] & reg[r2]; } } if (0x0200 & opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 & opbit) { reg[R\_PC] = reg[r1]; } // JMP if (0x0010 & opbit) // JSR { uint16\_t long\_flag = (instr >> 11) & 1; pc\_plus\_off = reg[R\_PC] + sign\_extend(instr & 0x7ff, 11); reg[R\_R7] = reg[R\_PC]; if (long\_flag) { reg[R\_PC] = pc\_plus\_off; } else { reg[R\_PC] = reg[r1]; } } if (0x0004 & opbit) { reg[r0] = mem\_read(pc\_plus\_off); } // LD if (0x0400 & opbit) { reg[r0] = mem\_read(mem\_read(pc\_plus\_off)); } // LDI if (0x0040 & opbit) { reg[r0] = mem\_read(base\_plus\_off); } // LDR if (0x4000 & opbit) { reg[r0] = pc\_plus\_off; } // LEA if (0x0008 & opbit) { mem\_write(pc\_plus\_off, reg[r0]); } // ST if (0x0800 & opbit) { mem\_write(mem\_read(pc\_plus\_off), reg[r0]); } // STI if (0x0080 & opbit) { mem\_write(base\_plus\_off, reg[r0]); } // STR if (0x8000 & opbit) // TRAP { {TRAP, 8} } //if (0x0100 & opbit) { } // RTI if (0x4666 & opbit) { update\_flags(r0); } }  
 static void (*op\_table[16])(uint16\_t) = { ins<0>, ins<1>, ins<2>, ins<3>, ins<4>, ins<5>, ins<6>, ins<7>, NULL, ins<9>, ins<10>, ins<11>, ins<12>, NULL, ins<14>, ins<15> };  
 **Примечание:** я узнал об этой технике из [эмулятора NES, разработанного Bisqwit](https://www.youtube.com/watch?v=QIUVSD3yqqE). Если вас интересует эмуляция или NES, настоятельно рекомендую его видеоролики.  
   
 Остальные версии C++ использует уже написанный код. Полная версия [здесь](https://justinmeiners.github.io/lc3-vm/src/lc3-alt.cpp).  
   
 {Includes, 12} {Registers, 3} {Condition Flags, 3} {Opcodes, 3} {Memory Mapped Registers, 11} {TRAP Codes, 8} {Memory Storage, 3} {Register Storage, 3} {Functions, 12} int running = 1; {Instruction C++, 14} {Op Table, 14} int main(int argc, const char* argv[]) { {Load Arguments, 12} {Setup, 12} enum { PC\_START = 0x3000 }; reg[R\_PC] = PC\_START; while (running) { uint16\_t instr = mem\_read(reg[R\_PC]++); uint16\_t op = instr >> 12; op\_table[op](instr); } {Shutdown, 12} }